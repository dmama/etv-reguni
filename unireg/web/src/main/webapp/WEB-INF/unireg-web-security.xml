<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:security="http://www.springframework.org/schema/security"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/security
          http://www.springframework.org/schema/security/spring-security-3.0.xsd">

	<!-- ======================== PERMISSIONS ======================= -->

	<bean id="filterSecurityInterceptor" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
		<property name="authenticationManager" ref="ifosecAuthenticationManager" />
		<property name="accessDecisionManager" ref="accessDecisionManager" />
		<property name="securityMetadataSource">
			<security:filter-security-metadata-source path-type="ant">
				<security:intercept-url pattern="/**/*.do" access="ROLE_USER"/>
				<security:intercept-url pattern="/*.do" access="ROLE_USER"/>
				<!-- Ne JAMAIS ajouter de roles sur cette ligne! -->
				<security:intercept-url pattern="/**" access="ROLE_ROOT"/>
			</security:filter-security-metadata-source>
		</property>
	</bean>

	<!-- ======================== FILTER CHAIN ======================= -->

	<!-- La chaine des filtres Spring à appliquer. -->
	<bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy">
		<security:filter-chain-map path-type="ant">
			<security:filter-chain pattern="/403.do" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/404.do" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/error.do" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/logout.do" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/logoutiam.do" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/errors/**" filters="securityContextPersistenceFilter" />
			<security:filter-chain pattern="/ws/**" filters="none" />
			<security:filter-chain pattern="/remoting/**" filters="none" />
			<security:filter-chain pattern="/chooseoid.do" filters="securityContextPersistenceFilter,iamAuthenticationProcessingFilter" />
			<security:filter-chain pattern="/authenticationfailed.do" filters="securityContextPersistenceFilter" />
			<!-- Version IAM + IFOSEC -->
			<security:filter-chain pattern="/**/*.do" filters="securityContextPersistenceFilter, logoutFilter, exceptionTranslationFilter, iamAuthenticationProcessingFilter, ifoSecAuthenticationProcessingFilter, contextHolderAwareRequestFilter, filterSecurityInterceptor" />
			<security:filter-chain pattern="/**" filters="securityContextPersistenceFilter" />
		</security:filter-chain-map>
	</bean>

	<!-- ======================== AUTHENTICATION ======================= -->

	<!-- effectue le mapping entre les rôles IAM et les rôles métier tels que définis dans l’application. -->
	<bean id="basicRolesGranter" class="ch.vd.registre.web.security.BasicRolesGranter">
		<property name="ignoreUndefinedMapping" value="true" />
		<property name="roleMappings">
			<map>
				<entry key="USER" value="ROLE_USER" />
				<entry key="USER_EXTERNE" value="ROLE_USER" />
				<!-- Dans IAM, certains environnements ont TESTER, d'autres DEVELOPPER -->
				<!-- C'est un ROLE de TESTER et pas de DEVELOPPER bien que les developpeurs en ont aussi besoin -->
				<!-- On doit donc prendre en compte les 2 ... -->
				<entry key="DEVELOPPER" value="ROLE_TESTER" />
				<entry key="TESTER" value="ROLE_TESTER" />
			</map>
		</property>
	</bean>

	<!-- Recupere l'utilisateur et ses roles depuis IAM -->
	<bean id="iamAuthenticationProvider" class="ch.vd.registre.web.security.IAMDaoAuthenticationProvider">
		<property name="basicRolesGranter" ref="basicRolesGranter"/>
	</bean>

	<!-- Recupere l'utilisateur et ses roles depuis IfoSec -->
	<bean id="ifosecAuthenticationProvider" class="ch.vd.uniregctb.security.IFOSecAuthenticationProvider" depends-on="uniregModeHelper">
	</bean>

	<!-- Verifie que l'utilisateur est bien authentifié. -->
	<bean id="ifosecAuthenticationManager" class="org.springframework.security.authentication.ProviderManager">
		<property name="providers">
			<list>
				<ref local="ifosecAuthenticationProvider" />
			</list>
		</property>
	</bean>

	<!-- Verifie que l'utilisateur est bien authentifié. -->
	<bean id="iamAuthenticationManager" class="org.springframework.security.authentication.ProviderManager">
		<property name="providers">
			<list>
				<ref local="iamAuthenticationProvider" />
			</list>
		</property>
	</bean>

	<!-- Recupere l'utilisateur siteminder dans le header si il n'est pas présent en session -->
	<bean id="iamAuthenticationProcessingFilter" class="ch.vd.uniregctb.security.UniregIAMAuthProcessingFilter">
		<property name="authenticationManager" ref="iamAuthenticationManager" />
	</bean>

	<!-- Recupere les données IFOSEc si elles ne sont pas présentes en session -->
	<bean id="ifoSecAuthenticationProcessingFilter" class="ch.vd.uniregctb.security.IFOSecAuthenticationProcessingFilter">
		<property name="authenticationManager" ref="ifosecAuthenticationManager" />
		<property name="serviceSecuriteService" ref="serviceSecuriteService" />
	</bean>
	
	<bean id="securityDebugConfig" class="ch.vd.uniregctb.security.SecurityDebugConfig">
		<property name="properties" ref="uniregExternalProperties" />
		<property name="ifoSecService" ref="ifoSecService" />
	</bean>

	<!-- Filtre de logout: Le securityContextLogoutHandler effectue le logout et invalide la session -->
	<bean id="logoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<constructor-arg value="/logoutIAM.do" />
		<constructor-arg>
			<list>
				<bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler">
					<property name="invalidateHttpSession" value="true" />
				</bean>
			</list>
		</constructor-arg>
		<property name="filterProcessesUrl" value="/logout"/>
	</bean>

	<!-- ===================== ACCESS DECISION ==================== -->

	<bean id="accessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased">
		<property name="allowIfAllAbstainDecisions" value="false"/>
		<property name="decisionVoters">
		<list>
			<ref bean="authVoter"/>
			<ref bean="roleVoter"/>
		</list>
		</property>
	</bean>

	<!-- An access decision voter that reads ROLE_* configuration settings -->
	<bean id="roleVoter" class="org.springframework.security.access.vote.RoleVoter"/>
	<bean id="authVoter" class="org.springframework.security.access.vote.AuthenticatedVoter"/>

	<!-- ===================== HTTP REQUEST SECURITY ==================== -->

	<!-- the fourth item in the chain: securityEnforcementFilter -->
	<bean id="exceptionTranslationFilter" class="org.springframework.security.web.access.ExceptionTranslationFilter">
		<property name="authenticationEntryPoint">
			<bean class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
				<property name="loginFormUrl" value="/login.do" />
			</bean>
		</property>
		<property name="accessDeniedHandler">
			<bean class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
				<property name="errorPage" value="/errors/403.jsp"/>
			</bean>
		</property>
	</bean>

	<!-- Handles any AccessDeniedException and AuthenticationException thrown within the filter chain -->
	<bean id="securityContextPersistenceFilter" class="org.springframework.security.web.context.SecurityContextPersistenceFilter"/>

	<!-- Allow the use of getRemoteUser(), getUserPrincipal(), etc on request for Spring Security -->
	<bean id="contextHolderAwareRequestFilter" class="org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter"/>

	<!-- This bean automatically receives AuthenticationEvent messages from	DaoAuthenticationProvider -->
	<!--<bean id="loggerListener" class="org.springframework.security.authentication.event.LoggerListener" />-->

	<!-- ================================================================ -->

	<!--&lt;!&ndash;  Sécurité sur les méthodes: Intercepteur de sécurité, autorise l'execution des methodes protégées aux seuls roles qui y ont accès. &ndash;&gt;-->
	<!--<bean id="attributes" class="org.acegisecurity.annotation.SecurityAnnotationAttributes" />-->
	<!--<bean id="objectDefinitionSource" class="org.acegisecurity.intercept.method.MethodDefinitionAttributes">-->
		<!--<property name="attributes" ref="attributes" />-->
	<!--</bean>-->
		<!---->
	<!--<bean id="methodSecurityInterceptor" class="org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor">-->
		<!--<property name="validateConfigAttributes" value="false" />-->
		<!--<property name="accessDecisionManager" ref="httpRequestAccessDecisionManager" />-->
		<!--<property name="authenticationManager" ref="ifosecAuthenticationManager" />-->
		<!--<property name="objectDefinitionSource" ref="objectDefinitionSource" />-->
	<!--</bean>-->

	<!--<bean id="methodDefinitionSourceAdvisor"  class="org.acegisecurity.intercept.method.aopalliance.MethodDefinitionSourceAdvisor">-->
		<!--<constructor-arg><ref local="methodSecurityInterceptor"/></constructor-arg>-->
	<!--</bean>-->
	<!---->
	<!--&lt;!&ndash; BeanNameAutoProxyCreator: Ajout de l'intercepteur de sécurité sur les méthodes des classes de Service&ndash;&gt;-->
	<!--<bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">-->
		<!--<property name="beanNames" value="*Service" />-->
		<!--<property name="interceptorNames">-->
			<!--<list>-->
				<!--<value>methodDefinitionSourceAdvisor</value>-->
			<!--</list>-->
		<!--</property>-->
	<!--</bean>-->
	
	<bean id="securiteDossierService" class="ch.vd.uniregctb.security.SecuriteDossierServiceImpl">
		<property name="serviceSecurite" ref="serviceSecuriteService" />
		<property name="tiersDAO" ref="tiersDAO" />
		<property name="droitAccesDAO" ref="droitAccesDAO" />
	</bean>

	<bean id="ifoSecService" class="ch.vd.uniregctb.security.IfoSecServiceImpl">
		<property name="securiteService" ref="serviceSecuriteService" />
	</bean>
	
	<bean id="securityProviderImpl" class="ch.vd.uniregctb.security.SecurityProviderImpl" depends-on="securityDebugConfig,auditManager">
		<property name="securiteDossierService" ref="securiteDossierService" />
		<property name="ifoSecService" ref="ifoSecService" />
	</bean>

	<bean id="securityProviderCache" class="ch.vd.uniregctb.security.SecurityProviderCache">
		<property name="target" ref="securityProviderImpl" />
		<property name="cacheManager" ref="ehCacheManager" />
		<property name="cacheName" value="securityProvider" />
		<property name="dataEventService" ref="dataEventService" />
		<property name="tiersDAO" ref="tiersDAO" />
		<property name="droitAccesDAO" ref="droitAccesDAO" />
		<property name="uniregCacheManager" ref="uniregCacheManager" />
		<property name="preloadTiersIds" value="false"/>
		<property name="transactionManager" ref="transactionManager" />
	</bean>

	<bean id="securityProvider" class="ch.vd.uniregctb.security.SecurityProvider">
		<property name="provider" ref="securityProviderCache" />
	</bean>

</beans>
