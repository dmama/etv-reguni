package ch.vd.unireg.metier.periodeexploitation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.jetbrains.annotations.NotNull;

import ch.vd.registre.base.date.DateRange;
import ch.vd.registre.base.date.DateRangeAdapterCallback;
import ch.vd.registre.base.date.DateRangeHelper;
import ch.vd.registre.base.date.RegDate;
import ch.vd.unireg.parametrage.ParametreAppService;
import ch.vd.unireg.regimefiscal.RegimeFiscalConsolide;
import ch.vd.unireg.regimefiscal.RegimeFiscalService;
import ch.vd.unireg.tiers.Entreprise;
import ch.vd.unireg.tiers.ForFiscal;
import ch.vd.unireg.type.CategorieEntreprise;
import ch.vd.unireg.type.GenreImpot;
import ch.vd.unireg.type.TypeAutoriteFiscale;

public class PeriodeExploitationServiceImpl implements PeriodeExploitationService {

	private static final DateRangeAdapterCallback RANGE_ADAPTER_CALLBACK = new DateRangeAdapterCallback();

	private ParametreAppService parametreAppService;
	private RegimeFiscalService regimeFiscalService;

	@NotNull
	@Override
	public List<PeriodeExploitation> determinePeriodesExploitation(@NotNull Entreprise entreprise, @NotNull PeriodeContext context) {

		// allons donc chercher les périodes de couverture des fors vaudois qui intersectent :
		// 1. les années civiles pour lesquelles Unireg doit envoyer les questionnaires SNC (entre la première PF de déclaration PM et l'année courante)
		// 2. les périodes pendant lesquelles l'entreprise a une forme juridique de type SP

		// quand a-t-on du SP ?
		final List<RegimeFiscalConsolide> regimesFiscaux = regimeFiscalService.getRegimesFiscauxVDNonAnnulesTrie(entreprise);
		final List<DateRange> rangesSP = new ArrayList<>(regimesFiscaux.size());
		for (RegimeFiscalConsolide regime : regimesFiscaux) {
			if (regime.getCategorie() == CategorieEntreprise.SP) {
				rangesSP.add(regime);
			}
		}

		// y en a-t-il ?
		if (rangesSP.isEmpty()) {
			return Collections.emptyList();
		}

		// quand génère-t-on des questionnaires SNC ?
		final DateRange periodeGestionUnireg = getPeriodeGestionSNC(context);

		// a-t-on des catégories d'entreprise SP dans la période de gestion par Unireg ?
		final List<DateRange> spDansPeriodeGestion = DateRangeHelper.intersections(periodeGestionUnireg, rangesSP);
		if (spDansPeriodeGestion == null || spDansPeriodeGestion.isEmpty()) {
			return Collections.emptyList();
		}

		// couverture des fors vaudois ?
		final List<ForFiscal> forsFiscaux = entreprise.getForsFiscauxNonAnnules(true);
		final List<ForFiscal> forsVaudois = forsFiscaux.stream()
				.filter(ff-> ff.getTypeAutoriteFiscale() == TypeAutoriteFiscale.COMMUNE_OU_FRACTION_VD && ff.getGenreImpot() == GenreImpot.REVENU_FORTUNE)
				.collect(Collectors.toList());

		final List<DateRange> couvertureVaudoiseFors = DateRangeHelper.merge(forsVaudois);
		if (couvertureVaudoiseFors == null || couvertureVaudoiseFors.isEmpty()) {
			return Collections.emptyList();
		}

		// couverture des fors vaudois pendant les périodes SP intéressantes ?
		final List<DateRange> periodesContinues = DateRangeHelper.intersections(couvertureVaudoiseFors, spDansPeriodeGestion);
		if (periodesContinues == null || periodesContinues.isEmpty()) {
			return Collections.emptyList();
		}

		// découpons maintenant par année civile ce qui nous reste
		final List<PeriodeExploitation> periodes = new ArrayList<>();
		for (int annee = periodeGestionUnireg.getDateDebut().year() ; annee <= RegDate.get().year() ; ++ annee) {

			final List<DateRange> periodesDansLAnnee = DateRangeHelper.extract(periodesContinues, RegDate.get(annee, 1, 1), RegDate.get(annee, 12, 31), RANGE_ADAPTER_CALLBACK);
			final int size = periodesDansLAnnee.size();
			if (size == 1) {
				// une seule période, on la prend telle quelle
				final PeriodeExploitation periodeExploitation = new PeriodeExploitationImpl(periodesDansLAnnee.get(0), extractForVaudois(forsVaudois, periodesDansLAnnee.get(0)));
				periodes.add(periodeExploitation);
			}
			else if (size > 1) {
				// plusieurs périodes, on prend le range englobant
				final DateRange overallRange = DateRangeHelper.getOverallRange(periodesDansLAnnee);
				final PeriodeExploitation periodeExploitation = new PeriodeExploitationImpl(overallRange, extractForVaudois(forsVaudois, overallRange));
				periodes.add(periodeExploitation);
			}
		}

		return periodes;
	}

	private ForFiscal extractForVaudois(List<ForFiscal> forFiscals, DateRange dateRange) {
		return forFiscals.stream().filter(forFiscal -> DateRangeHelper.intersect(forFiscal,dateRange)).findFirst().get();
	}

	@NotNull
	private DateRange getPeriodeGestionSNC(@NotNull PeriodeExploitationService.@NotNull PeriodeContext context) {
		final int premiereAnnee;
		switch (context) {
		case ENVOI_AUTO:
			premiereAnnee = parametreAppService.getPremierePeriodeFiscaleDeclarationsPersonnesMorales();
			break;
		case THEORIQUE:
			premiereAnnee = parametreAppService.getPremierePeriodeFiscalePersonnesMorales();
			break;
		default:
			throw new IllegalArgumentException();
		}
		return new DateRangeHelper.Range(RegDate.get(premiereAnnee, 1, 1), null);
	}

	public void setParametreAppService(ParametreAppService parametreAppService) {
		this.parametreAppService = parametreAppService;
	}

	public void setRegimeFiscalService(RegimeFiscalService regimeFiscalService) {
		this.regimeFiscalService = regimeFiscalService;
	}
}
